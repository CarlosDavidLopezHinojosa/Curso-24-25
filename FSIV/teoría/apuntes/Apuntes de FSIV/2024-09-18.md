# Tipos de Datos y Funciones de OpenCV en el Código

## Tipos de Datos de OpenCV

1. **`cv::Mat`**  
   - Tipo de dato principal para manejar imágenes y matrices en OpenCV.
   
2. **`cv::uint8_t`**  
   - Tipo de dato para representar enteros de 8 bits sin signo, utilizado para representar los valores de los píxeles en imágenes con profundidad de 8 bits (`CV_8U`).
   
3. **`cv::Point`**  
   - Tipo de dato para representar puntos en 2D (coordenadas \(x, y\)).

4. **`cv::Vec`**  
   - Tipo de dato para representar un vector de tamaño fijo. Se usa típicamente para representar píxeles con varios canales. Ejemplos comunes incluyen:
     - **`cv::Vec3b`**: Un vector de 3 valores de 8 bits sin signo (generalmente para representar un píxel en una imagen RGB).
     - **`cv::Vec3f`**: Un vector de 3 valores de tipo `float` (usado, por ejemplo, para operaciones en píxeles de imágenes en color flotante).

## Funciones de OpenCV

1. **`cv::split(const cv::Mat&, std::vector<cv::Mat>&)`**  
   - Esta función divide una imagen multicanal en sus canales individuales, almacenándolos en un vector de matrices.

2. **`cv::minMaxLoc(const cv::Mat&, double* minVal, double* maxVal, cv::Point* minLoc = 0, cv::Point* maxLoc = 0)`**  
   - Esta función encuentra los valores mínimo y máximo en una matriz y opcionalmente también sus ubicaciones en la imagen.

3. **`CV_Assert(bool condition)`**  
   - Macro para hacer una verificación de aserción. Si la condición es falsa, el programa se detiene y muestra un mensaje de error.

4. **`input.depth()`**  
   - Método que devuelve la profundidad de los elementos de la matriz (por ejemplo, `CV_8U` para 8 bits sin signo, `CV_32F` para flotante de 32 bits, etc.).

5. **`input.channels()`**  
   - Método que devuelve el número de canales en la matriz (por ejemplo, 1 para una imagen en escala de grises, 3 para una imagen en color BGR, etc.).

6. **`input.type()`**  
   - Método que devuelve un entero codificado que representa la combinación de la profundidad (tipo de dato) y el número de canales de la imagen.

## Otros Tipos

1. **`std::vector<T>`**  
   - Un contenedor estándar de C++ utilizado aquí para almacenar valores y ubicaciones mínimos y máximos de cada canal.

## Notas Adicionales
- Los tipos **`uchar`** y **`u_char`** (probablemente deberían ser **`cv::uint8_t`** o **`unsigned char`**) también están relacionados con el tipo de datos de los píxeles para imágenes de 8 bits por canal.


## Realización de la práctica

```cpp
#pragma once
#include <vector>
#include <opencv2/core.hpp>

/**@brief Find the first max/min values and their locations.**/
void fsiv_find_min_max_loc_1(cv::Mat const& input,
std::vector<cv::uint8_t>& min_v, std::vector<cv::uint8_t>& max_v,
std::vector<cv::Point>& min_loc, std::vector<cv::Point>& max_loc);

/**
* @brief Find the first max/min values and their locations.
* The implementation must use the cv::minMaxLoc opencv function to vectorize the code.
**/
void fsiv_find_min_max_loc_2(cv::Mat const& input,

std::vector<double>& min_v, std::vector<double>& max_v,
std::vector<cv::Point>& min_loc, std::vector<cv::Point>& max_loc);
```

La funciones definidas arriba deberán encontrar los valores máximos y mínimos en los canales de una imagen, además de sus posiciones.

Una de manera iterativa y otra con una función propia de la librería.

### 1. Resolución Iterativa

```cpp
void fsiv_find_min_max_loc_1(cv::Mat const& input,
std::vector<cv::uint8_t>& min_v, std::vector<cv::uint8_t>& max_v,
std::vector<cv::Point>& min_loc, std::vector<cv::Point>& max_loc)

{

CV_Assert(input.depth()==CV_8U);
//! TODO: do a rows/cols scanning to find the first min/max values.

// Hint: use cv::split to get the input image channels.

std::vector<cv::Mat> channels;
cv::split(input,channels);

cv::uint8_t min, max;
cv::Point min_point, max_point;

for( auto channel : channels)
{
	min = 255;
	max = 0;

   for (size_t row = 0; row < channel.rows; row++)
   {
      for (size_t col = 0; col < channel.cols; col++)
      {

      const u_char pixel = channel.at<uchar>(row,col);

      if (min > pixel)
      {
         min = pixel;
         min_point = cv::Point(col,row);
      }

      if (max < pixel)
      {
         max = pixel;
         max_point = cv::Point(col,row);
      }
   }
}

min_v.push_back(min);
max_v.push_back(max);
min_loc.push_back(min_point);
max_loc.push_back(max_point);
}
//
CV_Assert(size_t(input.channels())==min_v.size());
CV_Assert(size_t(input.channels())==max_v.size());
CV_Assert(size_t(input.channels())==min_loc.size());
CV_Assert(size_t(input.channels())==max_loc.size());
}
```


### Resolución con función nativa de OpenCV

```cpp
void fsiv_find_min_max_loc_2(cv::Mat const& input,
    std::vector<double>& min_v, std::vector<double>& max_v,
    std::vector<cv::Point>& min_loc, std::vector<cv::Point>& max_loc)
{
    //! TODO: Find the first min/max values using cv::minMaxLoc function.    
    // Hint: use cv::split to get the input image channels.
    std::vector<cv::Mat> channels;
    cv::split(input,channels);

    double min, max;
    cv::Point min_point, max_point;

    for( auto channel : channels)
    {           
        cv::minMaxLoc(channel,&min,&max,&min_point,&max_point);
        min_v.push_back(min);
        max_v.push_back(max);
        min_loc.push_back(min_point);
        max_loc.push_back(max_point);
    }
    //
    CV_Assert(size_t(input.channels())==min_v.size());
    CV_Assert(size_t(input.channels())==max_v.size());
    CV_Assert(size_t(input.channels())==min_loc.size());
    CV_Assert(size_t(input.channels())==max_loc.size());
}
```